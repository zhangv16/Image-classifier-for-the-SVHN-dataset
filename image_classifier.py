# -*- coding: utf-8 -*-
"""Capstone Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_-rifX_ia5JZWS9lqZQKXlLSLbZvFF3S

# Capstone Project
## Image classifier for the SVHN dataset
### Instructions

In this notebook, you will create a neural network that classifies real-world images digits. You will use concepts from throughout this course in building, training, testing, validating and saving your Tensorflow classifier model.

This project is peer-assessed. Within this notebook you will find instructions in each section for how to complete the project. Pay close attention to the instructions as the peer review will be carried out according to a grading rubric that checks key parts of the project instructions. Feel free to add extra cells into the notebook as required.

### How to submit

When you have completed the Capstone project notebook, you will submit a pdf of the notebook for peer review. First ensure that the notebook has been fully executed from beginning to end, and all of the cell outputs are visible. This is important, as the grading rubric depends on the reviewer being able to view the outputs of your notebook. Save the notebook as a pdf (you could download the notebook with File -> Download .ipynb, open the notebook locally, and then File -> Download as -> PDF via LaTeX), and then submit this pdf for review.

### Let's get started!

We'll start by running some imports, and loading the dataset. For this project you are free to make further imports throughout the notebook as you wish.
"""

import tensorflow as tf
from sklearn.model_selection import train_test_split
from sklearn.datasets import load_diabetes
from scipy.io import loadmat
from tensorflow.keras.models import Sequential, load_model
from tensorflow.keras.layers import Dense, Flatten, Softmax, Dropout, BatchNormalization, Conv2D, MaxPool2D
from tensorflow.keras import regularizers
from tensorflow.keras.callbacks import EarlyStopping, ModelCheckpoint, ReduceLROnPlateau
import matplotlib.pyplot as plt
import numpy as np
import random
tf.config.run_functions_eagerly(True)

"""For the capstone project, you will use the [SVHN dataset](http://ufldl.stanford.edu/housenumbers/). This is an image dataset of over 600,000 digit images in all, and is a harder dataset than MNIST as the numbers appear in the context of natural scene images. SVHN is obtained from house numbers in Google Street View images.

* Y. Netzer, T. Wang, A. Coates, A. Bissacco, B. Wu and A. Y. Ng. "Reading Digits in Natural Images with Unsupervised Feature Learning". NIPS Workshop on Deep Learning and Unsupervised Feature Learning, 2011.

The train and test datasets required for this project can be downloaded from [here](http://ufldl.stanford.edu/housenumbers/train.tar.gz) and [here](http://ufldl.stanford.edu/housenumbers/test.tar.gz). Once unzipped, you will have two files: `train_32x32.mat` and `test_32x32.mat`. You should store these files in Drive for use in this Colab notebook.

Your goal is to develop an end-to-end workflow for building, training, validating, evaluating and saving a neural network that classifies a real-world image into one of ten classes.
"""

# Run this cell to connect to your Drive folder

from google.colab import drive
drive.mount('/content/drive')

# Load the dataset from your Drive folder

train = loadmat('/content/drive/MyDrive/Colab Notebooks/Getting started with TensorFlow 2/Week 5/train_32x32.mat')
test = loadmat('/content/drive/MyDrive/Colab Notebooks/Getting started with TensorFlow 2/Week 5/train_32x32.mat')

"""Both `train` and `test` are dictionaries with keys `X` and `y` for the input images and labels respectively.

## 1. Inspect and preprocess the dataset
* Extract the training and testing images and labels separately from the train and test dictionaries loaded for you.
* Select a random sample of images and corresponding labels from the dataset (at least 10), and display them in a figure.
* Convert the training and test images to grayscale by taking the average across all colour channels for each pixel. _Hint: retain the channel dimension, which will now have size 1._
* Select a random sample of the grayscale images and corresponding labels from the dataset (at least 10), and display them in a figure.
"""

# Splitting the data to train_data, train_label, test_data, test_label.

train_data = train['X']
train_data = train_data / 255
train_label = train['y']
train_label[train_label > 9] = 0
test_data = test['X']
test_data = test_data / 255
test_label = test['y']
test_label[test_label > 9] = 0
print(train_data.shape)

# Change data dimensions so it fits the model.

train_data = np.moveaxis(train_data, [0, 1, 2, 3], [1, 2, 3, 0])
test_data = np.moveaxis(test_data, [0, 1, 2, 3], [1, 2, 3, 0])
print(train_data.shape)

def show_rand_img(dataset, num):
    """show <num> number of images randomely from dataset <dataset>."""
    
    num_example = dataset.shape[0]
    rand_num = random.sample(range(0, num_example), num)
    fig, ax = plt.subplots(1, num, figsize=(num, 1))
    j = 0
    if dataset.shape[3] == 1:
        for i in range(num):
            ax[i].set_axis_off()
            ax[i].imshow(dataset[rand_num[j], :, :, 0], cmap=plt.get_cmap('gray'))
            j += 1
        return rand_num
    else:
        for i in range(num):
            ax[i].set_axis_off()
            ax[i].imshow(dataset[rand_num[j], :, :, :])
            j += 1
        return rand_num

# Show random images in train_data
show_rand_img(train_data, 20)

def img_to_grayscale(dataset):
    """Turn all the images in dataset <dataset> to grayscale."""
    
    gray = np.mean(train_data, axis=3, keepdims=True)
    return gray

# Create new datasets: gray_train_data, gray_test_data, which are the grayscale version of train_data, test_data

gray_train_data = img_to_grayscale(train_data)
gray_test_data = img_to_grayscale(test_data)
print(gray_train_data.shape)

# Show random images in gray_train_data and gray_test_data

show_rand_img(gray_train_data, 20)
show_rand_img(gray_test_data, 20)

"""## 2. MLP neural network classifier
* Build an MLP classifier model using the Sequential API. Your model should use only Flatten and Dense layers, with the final layer having a 10-way softmax output. 
* You should design and build the model yourself. Feel free to experiment with different MLP architectures. _Hint: to achieve a reasonable accuracy you won't need to use more than 4 or 5 layers._
* Print out the model summary (using the summary() method)
* Compile and train the model (we recommend a maximum of 30 epochs), making use of both training and validation sets during the training run. 
* Your model should track at least one appropriate metric, and use at least two callbacks during training, one of which should be a ModelCheckpoint callback.
* As a guide, you should aim to achieve a final categorical cross entropy training loss of less than 1.0 (the validation loss might be higher).
* Plot the learning curves for loss vs epoch and accuracy vs epoch for both training and validation sets.
* Compute and display the loss and accuracy of the trained model on the test set.
"""

def get_model(wd, rate):
    """Get a model with l2 regularization rate <wd>, and dropout rate <rate>. Return the model"""
    model = Sequential([
        Flatten(input_shape = (32, 32, 1)),
        Dense(512, activation='relu',  kernel_initializer='he_uniform',  kernel_regularizer=regularizers.l2(wd)),
        BatchNormalization(),
        Dropout(rate),
        Dense(512, activation='relu',  kernel_regularizer=regularizers.l2(wd)),
        BatchNormalization(),
        Dropout(rate),
        Dense(512, activation='relu',  kernel_regularizer=regularizers.l2(wd)),
        BatchNormalization(),
        Dropout(rate),
        Dense(512, activation='relu',  kernel_regularizer=regularizers.l2(wd)),
        BatchNormalization(),
        Dropout(rate),
        Dense(10, activation='softmax')
    ])
    return model

# Create a new model

model = get_model(1e-5, 0.1)
print(model.summary())

def compile_model(model, lr):
    """Compile the model <model> with learning rate <lr>. Return None"""
    opt = tf.keras.optimizers.Adam(learning_rate=lr)
    model.compile(optimizer=opt, loss='sparse_categorical_crossentropy', metrics=['accuracy'])

# Compile the model.

compile_model(model, 0.001)

# Creating callbacks.

early_stopping = EarlyStopping(patience=5, monitor='val_accuracy', verbose=1)

checkpoint_best_path = 'model_checkpoints_best/checkpoint'
checkpoint_best = ModelCheckpoint(filepath='checkpoint_best_path',
                                  save_freq='epoch',
                                  monitor='val_accuracy',
                                  save_best_only=True,
                                  verbose=1)

reduce_lr = ReduceLROnPlateau(factor=0.2, patience=20)

# Train the model.

history = model.fit(gray_train_data,
                    train_label,
                    epochs=30,
                    batch_size=64,
                    validation_split=0.02,
                    callbacks=[early_stopping, checkpoint_best, reduce_lr],
                    verbose=True)

# Evaluate the model on test set.

model.evaluate(gray_test_data, test_label, verbose=2)

# Plot the training and validation loss.

plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('Loss vs. epochs')
plt.ylabel('Loss')
plt.xlabel('Epoch')
plt.legend(['Training', 'Validation'], loc='upper right')
plt.show()

"""## 3. CNN neural network classifier
* Build a CNN classifier model using the Sequential API. Your model should use the Conv2D, MaxPool2D, BatchNormalization, Flatten, Dense and Dropout layers. The final layer should again have a 10-way softmax output. 
* You should design and build the model yourself. Feel free to experiment with different CNN architectures. _Hint: to achieve a reasonable accuracy you won't need to use more than 2 or 3 convolutional layers and 2 fully connected layers.)_
* The CNN model should use fewer trainable parameters than your MLP model.
* Compile and train the model (we recommend a maximum of 30 epochs), making use of both training and validation sets during the training run.
* Your model should track at least one appropriate metric, and use at least two callbacks during training, one of which should be a ModelCheckpoint callback.
* You should aim to beat the MLP model performance with fewer parameters!
* Plot the learning curves for loss vs epoch and accuracy vs epoch for both training and validation sets.
* Compute and display the loss and accuracy of the trained model on the test set.
"""

def get_CNN_model(wd):
    model = Sequential([
        Conv2D(filters=10,
               kernel_size=3,
               padding='SAME',
               activation='relu',
               input_shape=(32, 32, 1)),
        MaxPool2D(pool_size=(3, 3)),
        Conv2D(filters=10,
               kernel_size=3,
               padding='SAME',
               activation='relu'),
        MaxPool2D(pool_size=(3, 3)),
        Flatten(),
        BatchNormalization(),
        Dense(128, activation='relu', kernel_regularizer=regularizers.l2(wd)),
        Dense(128, activation='relu', kernel_regularizer=regularizers.l2(wd)),
        Dense(10, activation='softmax')
    ])
    return model

# Get CNN model.

cnn_model = get_CNN_model(1e-5)
cnn_model.summary()

# Compile the model.

compile_model(cnn_model, 0.001)

# Creating callbacks.

early_stopping_cnn = EarlyStopping(patience=5, monitor='val_accuracy', verbose=1)

checkpoint_best_path_cnn = 'model_checkpoints_best_cnn/checkpoint'
checkpoint_best_cnn = ModelCheckpoint(filepath='checkpoint_best_path_cnn',
                                  save_freq='epoch',
                                  monitor='val_accuracy',
                                  save_best_only=True,
                                  verbose=1)

# Train the model.

history = cnn_model.fit(gray_train_data,
                    train_label,
                    epochs=30,
                    batch_size=64,
                    validation_split=0.02,
                    callbacks=[early_stopping_cnn, checkpoint_best_cnn, reduce_lr],
                    verbose=True)

# Evaluate the model on test set.

cnn_model.evaluate(gray_test_data, test_label, verbose=2)

plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('Loss vs. epochs')
plt.ylabel('Loss')
plt.xlabel('Epoch')
plt.legend(['Training', 'Validation'], loc='upper right')
plt.show()

"""## 4. Get model predictions
* Load the best weights for the MLP and CNN models that you saved during the training run.
* Randomly select 5 images and corresponding labels from the test set and display the images with their labels.
* Alongside the image and label, show each model’s predictive distribution as a bar chart, and the final model prediction given by the label with maximum probability.
"""

# load models
cnnmod = load_model('checkpoint_best_path_cnn')
mlpmod = load_model('checkpoint_best_path')

# Randomly selet 5 images and corresponding labels from test_data and test_label

rand_num = random.sample(range(0, 73256), 5)

rand_num = show_rand_img(gray_test_data, 5)
for i in rand_num:
  print(f"Label: {test_label[i]}")

# Predictions

cnn_predictions = []
for i in range(5):
    img = gray_test_data[rand_num[i], :, :, :]
    cnn_predictions.append(np.argmax(cnnmod.predict(img[np.newaxis, ...])))
print('CNN predictions: ' + str(cnn_predictions))

mlp_predictions = []
for i in range(5):
    img = gray_test_data[rand_num[i], :, :, :]
    mlp_predictions.append(np.argmax(mlpmod.predict(img[np.newaxis, ...])))
print('MLP predictions: ' + str(mlp_predictions))